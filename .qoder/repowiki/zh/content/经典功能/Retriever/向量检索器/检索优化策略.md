# 检索优化策略

<cite>
**本文档中引用的文件**  
- [base.py](file://libs/core/langchain_core/vectorstores/base.py)
- [vectorstores.py](file://libs/partners/qdrant/langchain_qdrant/vectorstores.py)
- [ensemble.py](file://libs/langchain/langchain_classic/retrievers/ensemble.py)
- [multi_vector.py](file://libs/langchain/langchain_classic/retrievers/multi_vector.py)
- [cache.py](file://libs/langchain/langchain_classic/embeddings/cache.py)
- [utils.py](file://libs/core/langchain_core/vectorstores/utils.py)
</cite>

## 目录
1. [引言](#引言)
2. [相似度度量算法](#相似度度量算法)
3. [搜索参数优化](#搜索参数优化)
4. [混合检索策略](#混合检索策略)
5. [性能优化建议](#性能优化建议)
6. [监控与持续优化](#监控与持续优化)
7. [结论](#结论)

## 引言
向量检索器在现代信息检索系统中扮演着关键角色，特别是在处理大规模非结构化数据时。通过将文本嵌入到高维向量空间中，系统能够基于语义相似性进行高效检索。然而，检索性能受到多种因素的影响，包括相似度度量算法的选择、搜索参数的配置、混合检索策略的应用以及系统级优化措施。本文档深入探讨这些方面，提供全面的优化策略，帮助开发者构建高效、准确的向量检索系统。

## 相似度度量算法

向量检索器的性能和准确性在很大程度上取决于所选择的相似度度量算法。不同的度量方法适用于不同的数据特性和应用场景。在LangChain框架中，支持多种距离策略，包括余弦相似度、点积和欧几里得距离。

### 余弦相似度
余弦相似度是衡量两个向量方向相似性的常用方法，特别适用于文本嵌入，因为文本嵌入通常经过归一化处理。在代码实现中，余弦相似度通过以下公式进行转换，将距离值映射到[0,1]的相似度分数范围：

```python
@staticmethod
def _cosine_relevance_score_fn(distance: float) -> float:
    """将距离归一化为[0, 1]范围内的分数。"""
    return 1.0 - distance
```

该方法对向量的长度不敏感，只关注方向，因此在处理不同长度的文本时表现稳定。

### 欧几里得距离
欧几里得距离衡量两个向量之间的直线距离。对于归一化的嵌入向量，欧几里得距离的范围为[0, √2]。为了将其转换为[0,1]范围内的相似度分数，使用以下公式：

```python
@staticmethod
def _euclidean_relevance_score_fn(distance: float) -> float:
    """返回[0, 1]范围内的相似度分数。"""
    return 1.0 - distance / math.sqrt(2)
```

这种方法对向量的绝对位置敏感，适用于需要精确距离度量的场景。

### 点积（最大内积）
点积度量，也称为最大内积搜索（MIPS），在某些嵌入模型中被用作相似度度量。其相关性分数函数根据距离值的正负进行不同的处理：

```python
@staticmethod
def _max_inner_product_relevance_score_fn(distance: float) -> float:
    """将距离归一化为[0, 1]范围内的分数。"""
    if distance > 0:
        return 1.0 - distance
    return -1.0 * distance
```

这种度量方式在处理未归一化的嵌入向量时特别有效。

**Section sources**
- [base.py](file://libs/core/langchain_core/vectorstores/base.py#L430-L462)
- [vectorstores.py](file://libs/partners/qdrant/langchain_qdrant/vectorstores.py#L1944-L1977)

## 搜索参数优化

搜索参数的合理配置对检索质量和性能有显著影响。通过调整这些参数，可以在检索速度和结果准确性之间找到最佳平衡点。

### Top-k 参数
`k` 参数决定了返回的最相似文档的数量。较小的 `k` 值可以提高检索速度，但可能遗漏相关文档；较大的 `k` 值可以提高召回率，但会增加计算开销和响应时间。在实际应用中，需要根据具体需求进行权衡。

```python
def similarity_search(
    self, query: str, k: int = 4, **kwargs: Any
) -> list[Document]:
    """返回与查询最相似的文档。"""
```

### 相似度阈值
`score_threshold` 参数允许设置一个最小相似度阈值，过滤掉低于该阈值的结果。这对于确保返回结果的相关性非常有用，尤其是在需要高精度检索的场景中。

```python
def similarity_search_with_relevance_scores(
    self,
    query: str,
    k: int = 4,
    **kwargs: Any,
) -> list[tuple[Document, float]]:
    """返回文档及其相关性分数，范围为[0, 1]。"""
    score_threshold = kwargs.pop("score_threshold", None)
    # ... 过滤低于阈值的结果
```

### 最大边际相关性（MMR）
MMR 算法在优化查询相似性的同时，还考虑了结果之间的多样性。通过 `lambda_mult` 参数控制多样性的程度，`0` 表示最大多样性，`1` 表示最小多样性。

```python
def max_marginal_relevance_search(
    self,
    query: str,
    k: int = 4,
    fetch_k: int = 20,
    lambda_mult: float = 0.5,
    **kwargs: Any,
) -> list[Document]:
    """使用最大边际相关性返回文档。"""
```

**Section sources**
- [base.py](file://libs/core/langchain_core/vectorstores/base.py#L895-L963)
- [multi_vector.py](file://libs/langchain/langchain_classic/retrievers/multi_vector.py#L934-L956)

## 混合检索策略

混合检索策略结合了向量搜索和关键词搜索的优势，能够提供更全面和准确的检索结果。通过融合多种检索方法，系统可以同时利用语义相似性和关键词匹配。

### 稀疏与密集向量融合
在Qdrant向量存储中，支持稀疏向量和密集向量的混合检索。系统首先从密集向量和稀疏向量中分别检索前k个结果，然后使用融合查询（如RRF - Reciprocal Rank Fusion）将结果合并。

```python
elif self.retrieval_mode == RetrievalMode.HYBRID:
    embeddings = self._require_embeddings("HYBRID mode")
    query_dense_embedding = embeddings.embed_query(query)
    query_sparse_embedding = self.sparse_embeddings.embed_query(query)
    results = self.client.query_points(
        prefetch=[
            models.Prefetch(
                using=self.vector_name,
                query=query_dense_embedding,
                filter=filter,
                limit=k,
                params=search_params,
            ),
            models.Prefetch(
                using=self.sparse_vector_name,
                query=models.SparseVector(
                    indices=query_sparse_embedding.indices,
                    values=query_sparse_embedding.values,
                ),
                filter=filter,
                limit=k,
                params=search_params,
            ),
        ],
        query=hybrid_fusion or models.FusionQuery(fusion=models.Fusion.RRF),
        **query_options,
    ).points
```

### 加权倒数排名融合（RRF）
RRF 是一种常用的融合算法，它通过加权倒数排名来组合多个检索器的结果。每个文档的最终得分是其在各个检索器中排名的加权倒数之和。

```python
def weighted_reciprocal_rank(
    self,
    doc_lists: list[list[Document]],
) -> list[Document]:
    """对多个排名列表执行加权倒数排名融合。"""
    rrf_score: dict[str, float] = defaultdict(float)
    for doc_list, weight in zip(doc_lists, self.weights, strict=False):
        for rank, doc in enumerate(doc_list, start=1):
            rrf_score[
                doc.page_content if self.id_key is None else doc.metadata[self.id_key]
            ] += weight / (rank + self.c)
    # ... 根据RRF分数排序
```

**Section sources**
- [vectorstores.py](file://libs/partners/qdrant/langchain_qdrant/vectorstores.py#L589-L626)
- [ensemble.py](file://libs/langchain/langchain_classic/retrievers/ensemble.py#L260-L297)

## 性能优化建议

为了提升向量检索器的整体性能，可以采取多种优化措施，包括索引预热、结果缓存和异步查询处理。

### 索引预热
索引预热是指在系统启动或高峰期前，预先加载常用的索引数据到内存中，以减少首次查询的延迟。虽然代码中没有直接的预热实现，但可以通过批量加载常用查询的嵌入向量来间接实现。

### 结果缓存
结果缓存是提升性能的有效手段，特别是对于频繁查询的文本。`CacheBackedEmbeddings` 类提供了一个缓存机制，可以将文档和查询的嵌入向量存储在键值存储中，避免重复计算。

```python
class CacheBackedEmbeddings(Embeddings):
    """用于缓存嵌入模型结果的接口。"""
    
    def embed_documents(self, texts: list[str]) -> list[list[float]]:
        """嵌入文档列表，首先检查缓存。"""
        vectors: list[list[float] | None] = self.document_embedding_store.mget(texts)
        # ... 如果缓存中不存在，则计算并存储
```

### 异步查询处理
异步处理可以显著提高系统的吞吐量和响应能力。通过使用异步方法，系统可以在等待I/O操作完成的同时处理其他请求。

```python
async def asimilarity_search(
    self, query: str, k: int = 4, **kwargs: Any
) -> list[Document]:
    """异步返回与查询最相似的文档。"""
    return await run_in_executor(None, self.similarity_search, query, k=k, **kwargs)
```

**Section sources**
- [cache.py](file://libs/langchain/langchain_classic/embeddings/cache.py#L346-L369)
- [base.py](file://libs/core/langchain_core/vectorstores/base.py#L430-L462)

## 监控与持续优化

有效的监控是实现持续优化的基础。通过监控检索延迟、准确率和资源消耗，可以及时发现性能瓶颈并进行调整。

### 检索延迟监控
检索延迟是衡量系统性能的关键指标。可以通过记录每次查询的开始和结束时间来计算延迟，并设置告警阈值。

```python
# 在回调处理器中监控执行时间
def on_retriever_start_common(self) -> None:
    self.starts += 1
    self.retriever_starts += 1

def on_retriever_end_common(self) -> None:
    self.ends += 1
    self.retriever_ends += 1
```

### 准确率评估
准确率可以通过人工评估或使用预定义的测试集来衡量。定期评估检索结果的相关性，并根据反馈调整相似度阈值和搜索参数。

### 资源消耗监控
监控CPU、内存和网络带宽的使用情况，确保系统在高负载下仍能稳定运行。对于云部署，还需要监控API调用次数和成本。

### 持续优化
基于监控数据，持续优化系统配置。例如，如果发现某些查询的延迟较高，可以考虑增加缓存大小或优化索引结构。如果准确率不达标，可以尝试调整相似度度量算法或引入更复杂的混合检索策略。

**Section sources**
- [base.py](file://libs/core/langchain_core/vectorstores/base.py#L430-L462)
- [ensemble.py](file://libs/langchain/langchain_classic/retrievers/ensemble.py#L133-L175)

## 结论
向量检索器的性能优化是一个多维度的挑战，涉及算法选择、参数调优、策略设计和系统级优化。通过合理选择相似度度量算法，精细调整搜索参数，采用混合检索策略，并实施有效的性能优化措施，可以显著提升检索系统的效率和准确性。同时，建立完善的监控体系，实现持续优化，是确保系统长期稳定运行的关键。未来的工作可以进一步探索更先进的融合算法和自适应优化技术，以应对不断变化的应用需求。